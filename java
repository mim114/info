java -version
javac                                              компилятор
src                                                папка с исходниками
bin                                                папка с байт-кодом
name.java                                          файл с исходником
name.class                                         файл с байт-кодом   
name.jar                                           архив с файлами программы

кросплатформиность
автоматическое управление памятью (нож а не катана)
инкапсуляция по отношению к железу
JRE                                               среда выполнения
JDK                                               среда разработки
.                                                 оператор доступа

функция --------------------> программа возвращающая какое-то значение
процес  --------------------> программа выполняющая какое-то действие
метод  ---------------------> функция или процесс принадлижащий классу
параметр -------------------> тип и количество принемаемого значения 
аргумент -------------------> значение передаваемое нв выполнение в метод

1. Легкость понемания. Абстракция на уровне объектов реального мира.
2. Гибкость кода. Возможность рефакторинга блока кода.
3. Расширяемость.
4. Повторное использование.
5. Низкая стоимость сопровождения кода.
6. Более высокая производительность.

1. Абстракция
2. Инкапсуляция  ----> объединение данных и методов в один объект и сокрытее д                       еталей реализации.
3. Наследование  ----> это преобретение состояния и поведения родителя
4. Полиморфизм ------> это спасобность метода обрабатывать данные разных типов

типизированные / нетипизированные
статическая / динамическая      // типизация во время компиляции.
                                // типизация во время выполнения
сильная / слабая                // нельзя смешивать типы.  
                                // неявное преоброзование 
явная / неявная           

##############################################################################

ассоциация __-______________a + b = b + a
комутация __________________a + (b + c) = (a + b) + c
дистрибуция_________________a(b + c) = ab + ac
композиция__________________двигатель -> машина. является неотделимой частью
агрегация __________________пассажир -> машина. является отделимой частью

****************************************************************************
АЛГОРИТМ это последовательность действий для решения задачи.

1. дискретность-----------> алгоритм разбит на отдельные шаги
2. однозначность----------> четко прописанное действие
3. понятность-------------> входит в систему команд исполнителя
4. результативность-------> задача должна быть решена за конечное число шагов

'a' линейный
'b' витвление
'c' циклический
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
Этапы написания программы

1. Постановка задачи
2. Выбор метода решения
3. Разработка алгоритма
4. Написание кода
5. Компиляция
6. Тестирование
7. Создание doc.file
8. Соправождение

   ЯЗЫКИ ПРОГРАММИРЫВАНИЯ
                 процедурные               НЕпроцидурные
  низкого уравня    высокого уравня   ООП                дикларотивные
  ассамблер         java script       java                HTML

package src;  // избежание конфликта имен. контроль доступа (инкапсуляция)
              // встроенные пакеты. пользовательские пакеты

import java.util.Scaner;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        byte    name0 = 1;      // 0    1byte  - 128 до 127          Byte
        short   name1 = 1;      // 0    2byte  -32_768 до 32_767     Short
        int     name2 = 1;      // 0    4byte  -2^9 до 2^9           Integer
        long    name3 = 1;      // 0L   8byte  -9^18 до 9^18         Long
        float   name4 = 0.1F;   // 0.0f 4byte  7знаков после точки   Float
        double  name5 = 0.1;    // 0.0d 8byte  15знаков после точки  Double
        char    name6 = 'A';    // \u0000 2byte 0 до 65_635          Character
        boolean name7 = true;   // false  4/2 от jvm                 Boolean
        BigInteger a  = 3;
        BigDicimal b  = 0.1;
        String str    = "Hello, world!";    // поиск в pool одинаковых 
                                            // str.length();
        String str1   = new String("Hello");// создание в pool новой сущности
        StringBilder  = "Java";
        StringBuffer  = "Multi";
        int[] arry    = new int[8];         // 2_147_483_647 элиментов
        byte[] arryB  = {'a', 'b'};         // это массив 
        int[][] doub  = new int[5][4];      // это двумерный массив
        arry[0]       = 5;
        int[] ar      = new int[5][];       // зубчатый массив
        ar[0]         = new int[10];             
        ArrayList<Integer> int;             // список основанный на массивах
        

        /* () [] .
           ++a b-- ! ~
           * / %      // int / int = int  5 / 2 = 3  int / double = double
           + -
           << >> >>>
           < > <= >=
           == !=
           &
           ^
           |
           &&
           ||
           a > 0 ? true : false
           = *= /= %= += -=
        */
************************************************************************
        условные операторы

        if (true) {
            // statment
        } else if {
            // statment
        } else {
            // statment
        }
****************************************************************************
        a > 0 ? true : false;                      //  тернарный
***************************************************************************
         switch (a) {
            case 1 -> System.out.println("Yes");
            default -> System.out.println("No");
        }
****************************************************************************
        int b = switch (name) {
            case 1:
                yield 11;
            defaulf:
                yield 0;
        };
****************************************************************************
       циклы

        for (int i = 1; i < array.length; i++) {
            // statment;
        
*****************************************************************************
        for (int i : list) {
            // statment;
        }
*****************************************************************************
        while (true) {
            // statment;
            continue
            // statmetn;
            break
        }
*****************************************************************************
        do {
        // statment;
        } while (true);
*****************************************************************************
        public int add(int a) {  // принемает аргумент по значению копируя его
            return a * 2;
         }
         
         public int add(double a) { // перегрузка (overloading)
                                    // изменение параметров
            return a * 2;
          }
         
         public void string(String... a) {
            System.out.println(a);
         }
          
          @override          // переопределение изменение материнского метода
          public void string(String... a) {
            System.out.println("he");
          }
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          
    class Ass extends Kiss {          // extends наследую
        int a;
        int a1;                      // композиция? агригация?
        public Ass(int a, int a1) {  // this() вызов конструктора
                                     // текущего класса
        this.a = a;                  // ссылка на объект текущего класса
        super(a1);                   // вызов конструктора родителького класса
        }
     }
   }
}

☢️


























    
/*
* ООП ... способ программирывания в виде представления программы как совокупности взаимодействующих объектов. Каждый объект является
* реализацией какого-то класса, а классы образованны в иерархическую структуру.
*
* Абстракция   --> разбиение чего-то большого, монолитного на составные части.
* Инкапсуляция --> сокрытие реализации и невозможность изменение состояния объекта извне.
* Наследывание --> получение состояния и свойств родительского класса.
* Полиморфизм  --> реализация различных свойств через единый интерфейс. 
* 
* Приимущества ООП:
* - лёгкое понимания логики кода
* - гибкость. Возможность добавлять и зменять.
* - повторное использование
* - безопасность. За счет инкапсуляции
* - дишевизна последующего сопровождения кода
* Недостатки ООП:
* - больший объём потребляемой памяти
* - сложность с повторным использованием. длинная цепочка зовисемостей
* -  
*/
